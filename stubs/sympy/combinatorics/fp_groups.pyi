from typing import Any, Callable
from sympy.combinatorics.coset_table import CosetTable
from sympy.combinatorics.free_groups import FreeGroupElement
from sympy.combinatorics.homomorphisms import GroupHomomorphism
from sympy.printing.defaults import DefaultPrinting
from sympy.utilities import public

@public
def fp_group(fr_grp, relators=...) -> tuple[FpGroup, *tuple[Any, ...]]:
    ...

@public
def xfp_group(fr_grp, relators=...) -> tuple[FpGroup, Callable[[], Any]]:
    ...

@public
def vfp_group(fr_grpm, relators) -> FpGroup:
    ...

class FpGroup(DefaultPrinting):
    is_group = ...
    is_FpGroup = ...
    is_PermutationGroup = ...
    def __init__(self, fr_grp, relators) -> None:
        ...
    
    def make_confluent(self) -> None:
        '''
        Try to make the group's rewriting system confluent

        '''
        ...
    
    def reduce(self, word):
        '''
        Return the reduced form of `word` in `self` according to the group's
        rewriting system. If it's confluent, the reduced form is the unique normal
        form of the word in the group.

        '''
        ...
    
    def equals(self, word1, word2) -> bool | None:
        '''
        Compare `word1` and `word2` for equality in the group
        using the group's rewriting system. If the system is
        confluent, the returned answer is necessarily correct.
        (If it is not, `False` could be returned in some cases
        where in fact `word1 == word2`)

        '''
        ...
    
    @property
    def identity(self):
        ...
    
    def __contains__(self, g) -> bool:
        ...
    
    def subgroup(self, gens, C=..., homomorphism=...) -> tuple[FpGroup, GroupHomomorphism] | FpGroup:
        '''
        Return the subgroup generated by `gens` using the
        Reidemeister-Schreier algorithm
        homomorphism -- When set to True, return a dictionary containing the images
                     of the presentation generators in the original group.

        Examples
        ========

        >>> from sympy.combinatorics.fp_groups import FpGroup
        >>> from sympy.combinatorics import free_group
        >>> F, x, y = free_group("x, y")
        >>> f = FpGroup(F, [x**3, y**5, (x*y)**2])
        >>> H = [x*y, x**-1*y**-1*x*y*x]
        >>> K, T = f.subgroup(H, homomorphism=True)
        >>> T(K.generators)
        [x*y, x**-1*y**2*x**-1]

        '''
        ...
    
    def coset_enumeration(self, H, strategy=..., max_cosets=..., draft=..., incomplete=...) -> CosetTable:
        ...
    
    def standardize_coset_table(self) -> None:
        ...
    
    def coset_table(self, H, strategy=..., max_cosets=..., draft=..., incomplete=...) -> list[list[None]]:
        ...
    
    def order(self, strategy=...) -> int | Any:
        ...
    
    def most_frequent_generator(self):
        ...
    
    def random(self):
        ...
    
    def index(self, H, strategy=...) -> int:
        ...
    
    def __str__(self) -> str:
        ...
    
    __repr__ = ...
    def derived_series(self) -> list[Any]:
        '''
        Return the list of lists containing the generators
        of the subgroups in the derived series of `self`.

        '''
        ...
    
    def lower_central_series(self) -> list[Any]:
        '''
        Return the list of lists containing the generators
        of the subgroups in the lower central series of `self`.

        '''
        ...
    
    def center(self) -> list[Any]:
        '''
        Return the list of generators of the center of `self`.

        '''
        ...
    
    def derived_subgroup(self) -> list[Any]:
        '''
        Return the list of generators of the derived subgroup of `self`.

        '''
        ...
    
    def centralizer(self, other) -> list[Any]:
        '''
        Return the list of generators of the centralizer of `other`
        (a list of elements of `self`) in `self`.

        '''
        ...
    
    def normal_closure(self, other) -> list[Any]:
        '''
        Return the list of generators of the normal closure of `other`
        (a list of elements of `self`) in `self`.

        '''
        ...
    
    @property
    def is_abelian(self) -> Any:
        '''
        Check if `self` is abelian.

        '''
        ...
    
    @property
    def is_nilpotent(self) -> Any:
        '''
        Check if `self` is nilpotent.

        '''
        ...
    
    @property
    def is_solvable(self) -> Any:
        '''
        Check if `self` is solvable.

        '''
        ...
    
    @property
    def elements(self) -> list[Any] | None:
        '''
        List the elements of `self`.

        '''
        ...
    
    @property
    def is_cyclic(self) -> bool:
        ...
    
    def abelian_invariants(self) -> list[Any]:
        ...
    
    def composition_series(self) -> list[Any]:
        ...
    


class FpSubgroup(DefaultPrinting):
    '''
    The class implementing a subgroup of an FpGroup or a FreeGroup
    (only finite index subgroups are supported at this point). This
    is to be used if one wishes to check if an element of the original
    group belongs to the subgroup

    '''
    def __init__(self, G, gens, normal=...) -> None:
        ...
    
    def __contains__(self, g) -> bool:
        ...
    
    def order(self):
        ...
    
    def to_FpGroup(self) -> Any:
        ...
    
    def __str__(self) -> str:
        ...
    
    __repr__ = ...


def low_index_subgroups(G, N, Y=...) -> list[Any]:
    ...

def descendant_subgroups(S, C, R1_c_list, x, R2, N, Y) -> None:
    ...

def try_descendant(S, C, R1_c_list, R2, N, alpha, x, beta, Y) -> None:
    ...

def first_in_class(C, Y=...) -> bool:
    ...

def simplify_presentation(*args, change_gens=...) -> FpGroup | tuple[Any, Any] | tuple[Any | list[Any], Any | list[Any]]:
    '''
    For an instance of `FpGroup`, return a simplified isomorphic copy of
    the group (e.g. remove redundant generators or relators). Alternatively,
    a list of generators and relators can be passed in which case the
    simplified lists will be returned.

    By default, the generators of the group are unchanged. If you would
    like to remove redundant generators, set the keyword argument
    `change_gens = True`.

    '''
    ...

def elimination_technique_1(gens, rels, identity) -> tuple[list[Any], list[Any]]:
    ...

def define_schreier_generators(C, homomorphism=...) -> None:
    '''
    Parameters
    ==========

    C -- Coset table.
    homomorphism -- When set to True, return a dictionary containing the images
                     of the presentation generators in the original group.
    '''
    ...

def reidemeister_relators(C) -> None:
    ...

def rewrite(C, alpha, w):
    ...

def elimination_technique_2(C) -> tuple[Any, Any]:
    ...

def reidemeister_presentation(fp_grp, H, C=..., homomorphism=...) -> tuple[tuple[Any, ...], tuple[Any, ...], list[Any]] | tuple[tuple[Any, ...], tuple[Any, ...]]:
    ...

FpGroupElement = FreeGroupElement
