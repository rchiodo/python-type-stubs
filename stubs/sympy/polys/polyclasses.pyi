from types import NotImplementedType
from typing import Any, Callable, Literal, Never, Self
from sympy.external.gmpy import GROUND_TYPES
from sympy.core.sympify import CantSympify
from sympy.polys.polyutils import PicklableWithSlots
from sympy.polys.domains import Domain

_flint_domains: tuple[Domain, ...]
if GROUND_TYPES == 'flint':
    _flint_domains = ...
else:
    flint = ...
    _flint_domains = ...
class DMP(CantSympify):
    __slots__ = ...
    def __new__(cls, rep, dom, lev=...) -> DUP_Flint | DMP_Python:
        ...
    
    @classmethod
    def new(cls, rep, dom, lev) -> DUP_Flint | DMP_Python:
        ...
    
    @property
    def rep(f):
        ...
    
    def to_best(f) -> DUP_Flint | DMP_Python | DMP | Self:
        ...
    
    @classmethod
    def from_dict(cls, rep, lev, dom) -> DUP_Flint | DMP_Python:
        ...
    
    @classmethod
    def from_list(cls, rep, lev, dom) -> DUP_Flint | DMP_Python:
        ...
    
    @classmethod
    def from_sympy_list(cls, rep, lev, dom) -> DUP_Flint | DMP_Python:
        ...
    
    @classmethod
    def from_monoms_coeffs(cls, monoms, coeffs, lev, dom) -> Self:
        ...
    
    def convert(f, dom) -> Self | DUP_Flint:
        ...
    
    @classmethod
    def zero(cls, lev, dom) -> DUP_Flint | DMP_Python:
        ...
    
    @classmethod
    def one(cls, lev, dom) -> DUP_Flint | DMP_Python:
        ...
    
    def __repr__(f) -> str:
        ...
    
    def __hash__(f) -> int:
        ...
    
    def __getnewargs__(self) -> tuple[Any, Any, Any]:
        ...
    
    def ground_new(f, coeff):
        ...
    
    def unify_DMP(f, g) -> tuple[Self | Any | DUP_Flint, DMP | Any | DUP_Flint | Self]:
        ...
    
    def to_dict(f, zero=...) -> dict[tuple[Literal[0]], Any] | dict[Any, Any]:
        ...
    
    def to_sympy_dict(f, zero=...) -> dict[tuple[Literal[0]], Any] | dict[Any, Any]:
        ...
    
    def to_sympy_list(f) -> list[Any]:
        ...
    
    def to_list(f):
        ...
    
    def to_tuple(f):
        ...
    
    def to_ring(f) -> Self | DUP_Flint:
        ...
    
    def to_field(f) -> Self | DUP_Flint:
        ...
    
    def to_exact(f) -> Self | DUP_Flint:
        ...
    
    def slice(f, m, n, j=...):
        ...
    
    def coeffs(f, order=...) -> list[Any]:
        ...
    
    def monoms(f, order=...) -> list[Any]:
        ...
    
    def terms(f, order=...) -> list[tuple[Any, Any]]:
        ...
    
    def all_coeffs(f) -> list[Any]:
        ...
    
    def all_monoms(f) -> list[tuple[Literal[0]]] | list[tuple[Any]]:
        ...
    
    def all_terms(f) -> list[tuple[tuple[Literal[0]], Any]] | list[tuple[tuple[Any], Any]]:
        ...
    
    def lift(f):
        ...
    
    def deflate(f):
        ...
    
    def inject(f, front=...):
        ...
    
    def eject(f, dom, front=...):
        ...
    
    def exclude(f) -> tuple[Any, Any]:
        ...
    
    def permute(f, P):
        ...
    
    def terms_gcd(f):
        ...
    
    def abs(f):
        ...
    
    def neg(f):
        ...
    
    def add_ground(f, c):
        ...
    
    def sub_ground(f, c):
        ...
    
    def mul_ground(f, c):
        ...
    
    def quo_ground(f, c):
        ...
    
    def exquo_ground(f, c):
        ...
    
    def add(f, g) -> Self:
        ...
    
    def sub(f, g) -> Self:
        ...
    
    def mul(f, g) -> Self:
        ...
    
    def sqr(f):
        ...
    
    def pow(f, n):
        ...
    
    def pdiv(f, g) -> tuple[Self, Self]:
        ...
    
    def prem(f, g) -> Self:
        ...
    
    def pquo(f, g) -> Self:
        ...
    
    def pexquo(f, g) -> Self:
        ...
    
    def div(f, g) -> tuple[Self, Self] | tuple[DUP_Flint, DUP_Flint]:
        ...
    
    def rem(f, g) -> Self:
        ...
    
    def quo(f, g) -> Self:
        ...
    
    def exquo(f, g) -> DUP_Flint | Self:
        ...
    
    def degree(f, j=...):
        ...
    
    def degree_list(f):
        ...
    
    def total_degree(f):
        ...
    
    def homogenize(f, s) -> DUP_Flint | DMP_Python:
        ...
    
    def homogeneous_order(f) -> int | None:
        ...
    
    def LC(f):
        ...
    
    def TC(f):
        ...
    
    def nth(f, *N):
        ...
    
    def max_norm(f):
        ...
    
    def l1_norm(f):
        ...
    
    def l2_norm_squared(f):
        ...
    
    def clear_denoms(f):
        ...
    
    def integrate(f, m=..., j=...):
        ...
    
    def diff(f, m=..., j=...):
        ...
    
    def eval(f, a, j=...):
        ...
    
    def half_gcdex(f, g) -> tuple[DUP_Flint, DUP_Flint] | tuple[Self, Self]:
        ...
    
    def gcdex(f, g) -> tuple[Self, Self, Self]:
        ...
    
    def invert(f, g) -> Self | DUP_Flint:
        ...
    
    def revert(f, n):
        ...
    
    def subresultants(f, g) -> list[DUP_Flint] | list[Self]:
        ...
    
    def resultant(f, g, includePRS=...) -> tuple[DUP_Flint | DMP_Python | Any | list[list[Any]] | list[Any], list[DUP_Flint]] | tuple[DUP_Flint | DMP_Python | Any | list[list[Any]] | list[Any], list[Self]] | DUP_Flint | DMP_Python | tuple[Any, list[Any]] | tuple[list[list[Any]], list[Any]] | tuple[list[list[Any]] | Any | list[Any], list[Any]] | list[list[Any]] | list[Any]:
        ...
    
    def discriminant(f):
        ...
    
    def cofactors(f, g) -> tuple[Any | DUP_Flint, DUP_Flint | Any | Self, Any] | tuple[Self, Self, Self]:
        ...
    
    def gcd(f, g) -> Self:
        ...
    
    def lcm(f, g) -> Self | DUP_Flint:
        ...
    
    def cancel(f, g, include=...) -> tuple[DUP_Flint | Any, Any] | tuple[Self, Self] | tuple[Any, Any, Self | Any | DUP_Flint, Any]:
        ...
    
    def trunc(f, p):
        ...
    
    def monic(f):
        ...
    
    def content(f):
        ...
    
    def primitive(f):
        ...
    
    def compose(f, g) -> Self:
        ...
    
    def decompose(f):
        ...
    
    def shift(f, a):
        ...
    
    def transform(f, p, q) -> Self:
        ...
    
    def sturm(f):
        ...
    
    def cauchy_upper_bound(f):
        ...
    
    def cauchy_lower_bound(f):
        ...
    
    def mignotte_sep_bound_squared(f):
        ...
    
    def gff_list(f):
        ...
    
    def norm(f):
        ...
    
    def sqf_norm(f):
        ...
    
    def sqf_part(f):
        ...
    
    def sqf_list(f, all=...):
        ...
    
    def sqf_list_include(f, all=...):
        ...
    
    def factor_list(f):
        ...
    
    def factor_list_include(f):
        ...
    
    def intervals(f, all=..., eps=..., inf=..., sup=..., fast=..., sqf=...):
        ...
    
    def refine_root(f, s, t, eps=..., steps=..., fast=...):
        ...
    
    def count_real_roots(f, inf=..., sup=...):
        ...
    
    def count_complex_roots(f, inf=..., sup=...):
        ...
    
    @property
    def is_zero(f):
        ...
    
    @property
    def is_one(f):
        ...
    
    @property
    def is_ground(f):
        ...
    
    @property
    def is_sqf(f):
        ...
    
    @property
    def is_monic(f):
        ...
    
    @property
    def is_primitive(f):
        ...
    
    @property
    def is_linear(f):
        ...
    
    @property
    def is_quadratic(f):
        ...
    
    @property
    def is_monomial(f):
        ...
    
    @property
    def is_homogeneous(f):
        ...
    
    @property
    def is_irreducible(f):
        ...
    
    @property
    def is_cyclotomic(f):
        ...
    
    def __abs__(f):
        ...
    
    def __neg__(f):
        ...
    
    def __add__(f, g) -> Self | NotImplementedType:
        ...
    
    def __radd__(f, g) -> Self | NotImplementedType:
        ...
    
    def __sub__(f, g) -> Self | NotImplementedType:
        ...
    
    def __rsub__(f, g):
        ...
    
    def __mul__(f, g) -> Self | NotImplementedType:
        ...
    
    def __rmul__(f, g) -> Self | NotImplementedType:
        ...
    
    def __truediv__(f, g) -> DUP_Flint | Self | NotImplementedType:
        ...
    
    def __rtruediv__(f, g) -> DUP_Flint | Self | NotImplementedType:
        ...
    
    def __pow__(f, n):
        ...
    
    def __divmod__(f, g) -> tuple[Self, Self] | tuple[DUP_Flint, DUP_Flint]:
        ...
    
    def __mod__(f, g) -> Self:
        ...
    
    def __floordiv__(f, g) -> Self | NotImplementedType:
        ...
    
    def __eq__(f, g) -> bool:
        ...
    
    def eq(f, g, strict=...):
        ...
    
    def ne(f, g, strict=...) -> bool:
        ...
    
    def __lt__(f, g) -> bool:
        ...
    
    def __le__(f, g) -> bool:
        ...
    
    def __gt__(f, g) -> bool:
        ...
    
    def __ge__(f, g) -> bool:
        ...
    
    def __bool__(f) -> bool:
        ...
    


class DMP_Python(DMP):
    __slots__ = ...
    def per(f, rep) -> Self:
        ...
    
    def ground_new(f, coeff) -> Self:
        ...
    
    def unify(f, g) -> tuple[Any, Any, Callable[..., Self], Any, Any] | tuple[Any, Any, Callable[..., Self], Any | list[Any] | list[list[Any]], Any | list[Any] | list[list[Any]]]:
        ...
    
    def to_DUP_Flint(f) -> DUP_Flint:
        ...
    
    def to_list(f) -> list[Any]:
        ...
    
    def to_tuple(f) -> tuple[Any, ...]:
        ...
    
    def deflate(f) -> tuple[tuple[Literal[1], ...] | tuple[Any, ...], Self]:
        ...
    
    def inject(f, front=...) -> Self:
        ...
    
    def eject(f, dom, front=...) -> Self:
        ...
    
    def terms_gcd(f) -> tuple[tuple[Literal[0], ...] | tuple[Any, ...], Self]:
        ...
    
    def abs(f) -> Self:
        ...
    
    def neg(f) -> Self:
        ...
    
    def sqr(f) -> Self:
        ...
    
    def degree_list(f) -> tuple[Any, ...]:
        ...
    
    def total_degree(f) -> int:
        ...
    
    def LC(f):
        ...
    
    def TC(f):
        ...
    
    def max_norm(f):
        ...
    
    def l1_norm(f) -> int:
        ...
    
    def l2_norm_squared(f) -> int:
        ...
    
    def clear_denoms(f) -> tuple[Any, Self]:
        ...
    
    def discriminant(f) -> DUP_Flint | DMP_Python | list[list[Any]] | list[Any]:
        ...
    
    def monic(f) -> Self:
        ...
    
    def content(f):
        ...
    
    def primitive(f) -> tuple[Any, Self]:
        ...
    
    def norm(f) -> DUP_Flint | DMP_Python:
        ...
    
    def sqf_norm(f) -> tuple[int, Self, DUP_Flint | DMP_Python]:
        ...
    
    def sqf_part(f) -> Self:
        ...
    
    def sqf_list(f, all=...) -> tuple[Any, list[tuple[Self, Any]]]:
        ...
    
    def sqf_list_include(f, all=...) -> list[tuple[Self, Literal[1]]]:
        ...
    
    def factor_list(f) -> tuple[Any, list[tuple[Self, Any]]]:
        ...
    
    def factor_list_include(f) -> list[tuple[Self, Any | Literal[1]]]:
        ...
    
    def count_real_roots(f, inf=..., sup=...) -> int:
        ...
    
    def count_complex_roots(f, inf=..., sup=...) -> int:
        ...
    
    @property
    def is_zero(f) -> bool:
        ...
    
    @property
    def is_one(f) -> bool:
        ...
    
    @property
    def is_ground(f) -> bool:
        ...
    
    @property
    def is_sqf(f) -> bool:
        ...
    
    @property
    def is_monic(f):
        ...
    
    @property
    def is_primitive(f):
        ...
    
    @property
    def is_linear(f) -> bool:
        ...
    
    @property
    def is_quadratic(f) -> bool:
        ...
    
    @property
    def is_monomial(f) -> bool:
        ...
    
    @property
    def is_homogeneous(f) -> bool:
        ...
    
    @property
    def is_irreducible(f) -> bool:
        ...
    
    @property
    def is_cyclotomic(f) -> bool:
        ...
    


class DUP_Flint(DMP):
    lev = ...
    __slots__ = ...
    def __reduce__(self) -> tuple[type[Self], tuple[Any, Any, int]]:
        ...
    
    def to_list(f):
        ...
    
    @classmethod
    def from_rep(cls, rep, dom) -> Self:
        ...
    
    def ground_new(f, coeff) -> Self:
        ...
    
    def unify(f, g):
        ...
    
    def to_DMP_Python(f) -> DMP_Python:
        ...
    
    def to_tuple(f) -> tuple[Any, ...]:
        ...
    
    def deflate(f) -> tuple[tuple[Literal[1]], Self] | tuple[tuple[Any], Self]:
        ...
    
    def inject(f, front=...):
        ...
    
    def eject(f, dom, front=...):
        ...
    
    def terms_gcd(f) -> tuple[tuple[Literal[0], ...] | tuple[Any, ...], DUP_Flint]:
        ...
    
    def abs(f) -> DUP_Flint:
        ...
    
    def neg(f) -> Self:
        ...
    
    def sqr(f) -> Self:
        ...
    
    def degree_list(f) -> tuple[float | Any]:
        ...
    
    def total_degree(f) -> float:
        ...
    
    def LC(f):
        ...
    
    def TC(f):
        ...
    
    def max_norm(f):
        ...
    
    def l1_norm(f) -> int:
        ...
    
    def l2_norm_squared(f) -> int:
        ...
    
    def clear_denoms(f) -> tuple[Any, Self]:
        ...
    
    def discriminant(f) -> DUP_Flint | DMP_Python | list[list[Any]] | list[Any]:
        ...
    
    def monic(f) -> Self:
        ...
    
    def content(f):
        ...
    
    def primitive(f) -> tuple[Any, Self]:
        ...
    
    def norm(f):
        ...
    
    def sqf_norm(f):
        ...
    
    def sqf_part(f) -> Self | DUP_Flint:
        ...
    
    def sqf_list(f, all=...) -> tuple[Any, list[tuple[DUP_Flint, Any]]]:
        ...
    
    def sqf_list_include(f, all=...) -> list[tuple[DUP_Flint, Literal[1]]]:
        ...
    
    def factor_list(f) -> tuple[Any, list[tuple[Self, Any]]]:
        ...
    
    def factor_list_include(f) -> list[tuple[DUP_Flint, Any | Literal[1]]]:
        ...
    
    def count_real_roots(f, inf=..., sup=...) -> int:
        ...
    
    def count_complex_roots(f, inf=..., sup=...) -> int:
        ...
    
    @property
    def is_zero(f) -> bool:
        ...
    
    @property
    def is_one(f):
        ...
    
    @property
    def is_ground(f):
        ...
    
    @property
    def is_linear(f):
        ...
    
    @property
    def is_quadratic(f):
        ...
    
    @property
    def is_monomial(f) -> bool:
        ...
    
    @property
    def is_monic(f):
        ...
    
    @property
    def is_primitive(f):
        ...
    
    @property
    def is_homogeneous(f) -> bool:
        ...
    
    @property
    def is_sqf(f) -> bool:
        ...
    
    @property
    def is_irreducible(f) -> bool:
        ...
    
    @property
    def is_cyclotomic(f) -> bool:
        ...
    


def init_normal_DMF(num, den, lev, dom) -> DMF:
    ...

class DMF(PicklableWithSlots, CantSympify):
    __slots__ = ...
    def __init__(self, rep, dom, lev=...) -> None:
        ...
    
    @classmethod
    def new(cls, rep, dom, lev=...) -> Self:
        ...
    
    def ground_new(self, rep) -> Self:
        ...
    
    def __repr__(f) -> str:
        ...
    
    def __hash__(f) -> int:
        ...
    
    def poly_unify(f, g) -> tuple[Any | int, Any, Callable[..., Any | Self], tuple[Any | list[Any], Any | list[Any]], Any] | tuple[Any | int, Any, Callable[..., Any | Self], tuple[Any | list[Any] | list[list[Any]], Any | list[Any] | list[list[Any]]], Any | list[Any] | list[list[Any]]]:
        ...
    
    def frac_unify(f, g) -> tuple[Any | int, Any, Callable[..., Any | Self], tuple[Any | list[Any], Any | list[Any]], tuple[Any | list[Any], Any | list[Any]]] | tuple[Any | int, Any, Callable[..., Any | Self], tuple[Any | list[Any] | list[list[Any]], Any | list[Any] | list[list[Any]]], tuple[Any | list[Any] | list[list[Any]], Any | list[Any] | list[list[Any]]]]:
        ...
    
    def per(f, num, den, cancel=..., kill=...) -> Self:
        ...
    
    def half_per(f, rep, kill=...) -> DUP_Flint | DMP_Python:
        ...
    
    @classmethod
    def zero(cls, lev, dom) -> Self:
        ...
    
    @classmethod
    def one(cls, lev, dom) -> Self:
        ...
    
    def numer(f) -> DUP_Flint | DMP_Python:
        ...
    
    def denom(f) -> DUP_Flint | DMP_Python:
        ...
    
    def cancel(f) -> Self:
        ...
    
    def neg(f) -> Self:
        ...
    
    def add_ground(f, c) -> Self | NotImplementedType:
        ...
    
    def add(f, g) -> Self:
        ...
    
    def sub(f, g) -> Self:
        ...
    
    def mul(f, g) -> Self:
        ...
    
    def pow(f, n) -> Self:
        ...
    
    def quo(f, g) -> Self:
        ...
    
    exquo = ...
    def invert(f, check=...) -> Self:
        ...
    
    @property
    def is_zero(f) -> bool:
        ...
    
    @property
    def is_one(f) -> bool:
        ...
    
    def __neg__(f) -> Self:
        ...
    
    def __add__(f, g) -> Self | NotImplementedType:
        ...
    
    def __radd__(f, g) -> Self | NotImplementedType:
        ...
    
    def __sub__(f, g) -> Self | NotImplementedType:
        ...
    
    def __rsub__(f, g) -> DMF | NotImplementedType:
        ...
    
    def __mul__(f, g) -> Self | NotImplementedType:
        ...
    
    def __rmul__(f, g) -> Self | NotImplementedType:
        ...
    
    def __pow__(f, n) -> Self:
        ...
    
    def __truediv__(f, g) -> Self | NotImplementedType:
        ...
    
    def __rtruediv__(self, g):
        ...
    
    def __eq__(f, g) -> bool:
        ...
    
    def __ne__(f, g) -> bool:
        ...
    
    def __lt__(f, g) -> bool:
        ...
    
    def __le__(f, g) -> bool:
        ...
    
    def __gt__(f, g) -> bool:
        ...
    
    def __ge__(f, g) -> bool:
        ...
    
    def __bool__(f) -> bool:
        ...
    


def init_normal_ANP(rep, mod, dom) -> ANP:
    ...

class ANP(CantSympify):
    __slots__ = ...
    def __new__(cls, rep, mod, dom) -> Self:
        ...
    
    @classmethod
    def new(cls, rep, mod, dom) -> Self:
        ...
    
    def __reduce__(self) -> tuple[type[ANP], tuple[Any, Any, Any]]:
        ...
    
    @property
    def rep(self):
        ...
    
    @property
    def mod(self):
        ...
    
    def to_DMP(self):
        ...
    
    def mod_to_DMP(self):
        ...
    
    def per(f, rep) -> Self:
        ...
    
    def __repr__(f) -> str:
        ...
    
    def __hash__(f) -> int:
        ...
    
    def convert(f, dom) -> Self:
        ...
    
    def unify(f, g) -> tuple[Any, Callable[..., Self], Any, Any, Any] | tuple[Any, Callable[..., ANP], Any | list[Any], Any | list[Any], Any | list[Any]]:
        ...
    
    def unify_ANP(f, g) -> tuple[Any, Any, Any, Any]:
        ...
    
    @classmethod
    def zero(cls, mod, dom) -> ANP:
        ...
    
    @classmethod
    def one(cls, mod, dom) -> ANP:
        ...
    
    def to_dict(f):
        ...
    
    def to_sympy_dict(f) -> dict[tuple[Literal[0]], Any] | dict[Any, Any] | dict[Never, Any]:
        ...
    
    def to_list(f):
        ...
    
    def mod_to_list(f):
        ...
    
    def to_sympy_list(f) -> list[Any]:
        ...
    
    def to_tuple(f):
        ...
    
    @classmethod
    def from_list(cls, rep, mod, dom) -> ANP:
        ...
    
    def add_ground(f, c) -> Self:
        ...
    
    def sub_ground(f, c) -> Self:
        ...
    
    def mul_ground(f, c) -> Self:
        ...
    
    def quo_ground(f, c) -> Self:
        ...
    
    def neg(f) -> Self:
        ...
    
    def add(f, g) -> Self:
        ...
    
    def sub(f, g) -> Self:
        ...
    
    def mul(f, g) -> Self:
        ...
    
    def pow(f, n) -> Self:
        ...
    
    def exquo(f, g) -> Self:
        ...
    
    def div(f, g) -> tuple[Self, ANP]:
        ...
    
    def quo(f, g) -> Self:
        ...
    
    def rem(f, g) -> ANP:
        ...
    
    def LC(f):
        ...
    
    def TC(f):
        ...
    
    @property
    def is_zero(f):
        ...
    
    @property
    def is_one(f):
        ...
    
    @property
    def is_ground(f):
        ...
    
    def __pos__(f) -> Self:
        ...
    
    def __neg__(f) -> Self:
        ...
    
    def __add__(f, g) -> Self | NotImplementedType:
        ...
    
    def __radd__(f, g) -> Self | NotImplementedType:
        ...
    
    def __sub__(f, g) -> Self | NotImplementedType:
        ...
    
    def __rsub__(f, g) -> Self | NotImplementedType:
        ...
    
    def __mul__(f, g) -> Self | NotImplementedType:
        ...
    
    def __rmul__(f, g) -> Self | NotImplementedType:
        ...
    
    def __pow__(f, n) -> Self:
        ...
    
    def __divmod__(f, g) -> tuple[Self, ANP]:
        ...
    
    def __mod__(f, g) -> ANP:
        ...
    
    def __truediv__(f, g) -> Self | NotImplementedType:
        ...
    
    def __eq__(f, g) -> bool:
        ...
    
    def __ne__(f, g) -> bool:
        ...
    
    def __lt__(f, g) -> bool:
        ...
    
    def __le__(f, g) -> bool:
        ...
    
    def __gt__(f, g) -> bool:
        ...
    
    def __ge__(f, g) -> bool:
        ...
    
    def __bool__(f) -> bool:
        ...
    


