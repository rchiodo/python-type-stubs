from itertools import chain
from types import NotImplementedType
from typing import Any, Self
from sympy.polys.matrices.dfm import DFM_dummy
from sympy.polys.matrices.sdm import SDM
from sympy.utilities.decorator import doctest_depends_on

class DDM(list):
    fmt = ...
    is_DFM = ...
    is_DDM = ...
    def __init__(self, rowslist, shape, domain) -> None:
        ...
    
    def getitem(self, i, j):
        ...
    
    def setitem(self, i, j, value) -> None:
        ...
    
    def extract_slice(self, slice1, slice2) -> DDM:
        ...
    
    def extract(self, rows, cols) -> DDM:
        ...
    
    @classmethod
    def from_list(cls, rowslist, shape, domain) -> Self:
        ...
    
    @classmethod
    def from_ddm(cls, other):
        ...
    
    def to_list(self) -> list[Any]:
        ...
    
    def to_list_flat(self) -> list[Any]:
        ...
    
    @classmethod
    def from_list_flat(cls, flat, shape, domain) -> Self:
        ...
    
    def flatiter(self) -> chain[Any]:
        ...
    
    def flat(self) -> list[Any]:
        ...
    
    def to_flat_nz(self) -> tuple[list[Any], tuple[tuple[tuple[Any, Any], ...], Any]]:
        ...
    
    @classmethod
    def from_flat_nz(cls, elements, data, domain) -> DDM:
        ...
    
    def to_dod(self) -> dict[Any, Any]:
        ...
    
    @classmethod
    def from_dod(cls, dod, shape, domain) -> DDM:
        ...
    
    def to_dok(self) -> dict[Any, Any]:
        ...
    
    @classmethod
    def from_dok(cls, dok, shape, domain) -> DDM:
        ...
    
    def to_ddm(self) -> Self:
        ...
    
    def to_sdm(self) -> SDM:
        ...
    
    @doctest_depends_on(ground_types=['flint'])
    def to_dfm(self) -> DFM_dummy:
        ...
    
    @doctest_depends_on(ground_types=['flint'])
    def to_dfm_or_ddm(self) -> DFM_dummy | Self:
        ...
    
    def convert_to(self, K) -> DDM:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    @classmethod
    def zeros(cls, shape, domain) -> DDM:
        ...
    
    @classmethod
    def ones(cls, shape, domain) -> DDM:
        ...
    
    @classmethod
    def eye(cls, size, domain) -> DDM:
        ...
    
    def copy(self) -> DDM:
        ...
    
    def transpose(self) -> DDM:
        ...
    
    def __add__(a, b) -> NotImplementedType | DDM:
        ...
    
    def __sub__(a, b) -> NotImplementedType | DDM:
        ...
    
    def __neg__(a) -> DDM:
        ...
    
    def __mul__(a, b) -> DDM | NotImplementedType:
        ...
    
    def __rmul__(a, b) -> DDM | NotImplementedType:
        ...
    
    def __matmul__(a, b) -> DDM | NotImplementedType:
        ...
    
    def add(a, b) -> DDM:
        ...
    
    def sub(a, b) -> DDM:
        ...
    
    def neg(a) -> DDM:
        ...
    
    def mul(a, b) -> DDM:
        ...
    
    def rmul(a, b) -> DDM:
        ...
    
    def matmul(a, b) -> DDM:
        ...
    
    def mul_elementwise(a, b) -> DDM:
        ...
    
    def hstack(A, *B) -> DDM:
        ...
    
    def vstack(A, *B) -> DDM:
        ...
    
    def applyfunc(self, func, domain) -> DDM:
        ...
    
    def nnz(a) -> int:
        ...
    
    def scc(a) -> list[Any]:
        ...
    
    @classmethod
    def diag(cls, values, domain) -> DDM:
        ...
    
    def rref(a) -> tuple[DDM, list[Any]]:
        ...
    
    def rref_den(a) -> tuple[DDM, Any, list[Any]]:
        ...
    
    def nullspace(a) -> tuple[DDM, list[int]] | tuple[DDM, list[Any]]:
        ...
    
    def nullspace_from_rref(a, pivots=...) -> tuple[DDM, list[int]] | tuple[DDM, list[Any]]:
        ...
    
    def particular(a) -> DDM:
        ...
    
    def det(a):
        ...
    
    def inv(a) -> DDM:
        ...
    
    def lu(a) -> tuple[DDM, DDM, list[Any]]:
        ...
    
    def lu_solve(a, b) -> DDM:
        ...
    
    def charpoly(a) -> list[Any]:
        ...
    
    def is_zero_matrix(self) -> bool:
        ...
    
    def is_upper(self) -> bool:
        ...
    
    def is_lower(self) -> bool:
        ...
    
    def is_diagonal(self) -> bool:
        ...
    
    def diagonal(self) -> list[Any]:
        ...
    
    def lll(A, delta=...):
        ...
    
    def lll_transform(A, delta=...) -> tuple[Any, Any | None]:
        ...
    


