from types import NotImplementedType
from typing import Any, Literal, Self
from sympy.core.basic import Basic
from sympy.core.power import Pow
from sympy.core.symbol import Symbol
from sympy.functions.elementary.miscellaneous import Max, Min
from sympy.matrices import SparseMatrix
from sympy.matrices.expressions.blockmatrix import BlockDiagMatrix, BlockMatrix
from sympy.matrices.expressions.permutation import PermutationMatrix
from sympy.matrices.immutable import ImmutableDenseMatrix
from sympy.printing.defaults import Printable
from sympy.series.order import Order
from sympy.tensor.array.array_derivatives import ArrayDerivative
from sympy.utilities.iterables import NotIterable
from sympy.core.decorators import call_highest_priority
from sympy.core.logic import FuzzyBool
from sympy.matrices.kind import MatrixKind
from numpy import ndarray as NDArray

class MatrixBase(Printable):
    _op_priority = ...
    __array_priority__ = ...
    is_Matrix = ...
    _class_priority = ...
    _sympify = ...
    zero = ...
    one = ...
    _diff_wrt: bool = ...
    rows: int = ...
    cols: int = ...
    _simplify = ...
    def __eq__(self, other) -> bool:
        ...
    
    def __getitem__(self, key):
        ...
    
    @property
    def shape(self) -> tuple[int, int]:
        ...
    
    def col_del(self, col):
        ...
    
    def col_insert(self, pos, other) -> Self:
        ...
    
    def col_join(self, other):
        ...
    
    def col(self, j):
        ...
    
    def extract(self, rowsList, colsList):
        ...
    
    def get_diag_blocks(self) -> list[Any]:
        ...
    
    @classmethod
    def hstack(cls, *args) -> Any:
        ...
    
    def reshape(self, rows, cols):
        ...
    
    def row_del(self, row):
        ...
    
    def row_insert(self, pos, other):
        ...
    
    def row_join(self, other):
        ...
    
    def diagonal(self, k=...):
        ...
    
    def row(self, i):
        ...
    
    def todok(self) -> dict[Any, Any]:
        ...
    
    def tolist(self) -> list[Any] | list[list[Any]]:
        ...
    
    def todod(M) -> dict[Any, Any]:
        ...
    
    def vec(self):
        ...
    
    def vech(self, diagonal=..., check_symmetry=...):
        ...
    
    @classmethod
    def vstack(cls, *args) -> Any:
        ...
    
    @classmethod
    def diag(kls, *args, strict=..., unpack=..., rows=..., cols=..., **kwargs):
        ...
    
    @classmethod
    def eye(kls, rows, cols=..., **kwargs):
        ...
    
    @classmethod
    def jordan_block(kls, size=..., eigenvalue=..., *, band=..., **kwargs):
        ...
    
    @classmethod
    def ones(kls, rows, cols=..., **kwargs):
        ...
    
    @classmethod
    def zeros(kls, rows, cols=..., **kwargs):
        ...
    
    @classmethod
    def companion(kls, poly):
        ...
    
    @classmethod
    def wilkinson(kls, n, **kwargs):
        ...
    
    def atoms(self, *types) -> set[Any]:
        ...
    
    @property
    def free_symbols(self) -> set[Any]:
        ...
    
    def has(self, *patterns) -> bool:
        ...
    
    def is_anti_symmetric(self, simplify=...) -> bool:
        ...
    
    def is_diagonal(self) -> bool:
        ...
    
    @property
    def is_weakly_diagonally_dominant(self) -> bool | None:
        ...
    
    @property
    def is_strongly_diagonally_dominant(self) -> bool | None:
        ...
    
    @property
    def is_hermitian(self) -> Literal[False]:
        ...
    
    @property
    def is_Identity(self) -> FuzzyBool:
        ...
    
    @property
    def is_lower_hessenberg(self) -> bool:
        ...
    
    @property
    def is_lower(self) -> bool:
        ...
    
    @property
    def is_square(self) -> bool:
        ...
    
    def is_symbolic(self) -> bool:
        ...
    
    def is_symmetric(self, simplify=...) -> Literal[False]:
        ...
    
    @property
    def is_upper_hessenberg(self) -> bool:
        ...
    
    @property
    def is_upper(self) -> bool:
        ...
    
    @property
    def is_zero_matrix(self) -> bool | None:
        ...
    
    def values(self) -> list[Any]:
        ...
    
    def adjoint(self):
        ...
    
    def applyfunc(self, f):
        ...
    
    def as_real_imag(self, deep=..., **hints) -> tuple[Any, Any]:
        ...
    
    def conjugate(self):
        ...
    
    def doit(self, **hints):
        ...
    
    def evalf(self, n=..., subs=..., maxn=..., chop=..., strict=..., quad=..., verbose=...):
        ...
    
    def expand(self, deep=..., modulus=..., power_base=..., power_exp=..., mul=..., log=..., multinomial=..., basic=..., **hints):
        ...
    
    @property
    def H(self):
        ...
    
    def permute(self, perm, orientation=..., direction=...) -> None:
        ...
    
    def permute_cols(self, swaps, direction=...) -> None:
        ...
    
    def permute_rows(self, swaps, direction=...) -> None:
        ...
    
    def refine(self, assumptions=...):
        ...
    
    def replace(self, F, G, map=..., simultaneous=..., exact=...) -> tuple[Any, dict[Any, Any]]:
        ...
    
    def rot90(self, k=...) -> Self | None:
        ...
    
    def simplify(self, **kwargs):
        ...
    
    def subs(self, *args, **kwargs):
        ...
    
    def trace(self) -> int:
        ...
    
    def transpose(self):
        ...
    
    @property
    def T(self):
        '''Matrix transposition'''
        ...
    
    @property
    def C(self):
        '''By-element conjugation'''
        ...
    
    def n(self, *args, **kwargs):
        ...
    
    def xreplace(self, rule):
        ...
    
    def upper_triangular(self, k=...):
        ...
    
    def lower_triangular(self, k=...):
        ...
    
    def __abs__(self):
        ...
    
    @call_highest_priority('__radd__')
    def __add__(self, other) -> NotImplementedType | Any:
        ...
    
    @call_highest_priority('__rtruediv__')
    def __truediv__(self, other):
        ...
    
    @call_highest_priority('__rmatmul__')
    def __matmul__(self, other) -> NotImplementedType | Any:
        ...
    
    def __mod__(self, other):
        ...
    
    @call_highest_priority('__rmul__')
    def __mul__(self, other) -> Any | NotImplementedType:
        ...
    
    def multiply(self, other, dotprodsimp=...) -> Any | NotImplementedType:
        ...
    
    def multiply_elementwise(self, other):
        ...
    
    def __neg__(self):
        ...
    
    @call_highest_priority('__rpow__')
    def __pow__(self, exp):
        ...
    
    def pow(self, exp, method=...):
        ...
    
    @call_highest_priority('__add__')
    def __radd__(self, other):
        ...
    
    @call_highest_priority('__matmul__')
    def __rmatmul__(self, other) -> NotImplementedType | Any:
        ...
    
    @call_highest_priority('__mul__')
    def __rmul__(self, other) -> Any | NotImplementedType:
        ...
    
    def rmultiply(self, other, dotprodsimp=...) -> Any | NotImplementedType:
        ...
    
    @call_highest_priority('__sub__')
    def __rsub__(self, a):
        ...
    
    @call_highest_priority('__rsub__')
    def __sub__(self, a):
        ...
    
    def adjugate(self, method=...):
        ...
    
    def charpoly(self, x=..., simplify=...) -> Any:
        ...
    
    def cofactor(self, i, j, method=...):
        ...
    
    def cofactor_matrix(self, method=...):
        ...
    
    def det(self, method=..., iszerofunc=...) -> tuple[Any | Basic, bool] | Any | Basic | Order:
        ...
    
    def per(self):
        ...
    
    def minor(self, i, j, method=...):
        ...
    
    def minor_submatrix(self, i, j):
        ...
    
    def echelon_form(self, iszerofunc=..., simplify=..., with_pivots=...) -> tuple[Any, tuple[Any, ...]]:
        ...
    
    @property
    def is_echelon(self) -> bool:
        ...
    
    def rank(self, iszerofunc=..., simplify=...) -> int:
        ...
    
    def rref_rhs(self, rhs) -> tuple[Any, Any]:
        ...
    
    def rref(self, iszerofunc=..., simplify=..., pivots=..., normalize_last=...) -> tuple[Any, Any | tuple[Any, ...]]:
        ...
    
    def elementary_col_op(self, op=..., col=..., k=..., col1=..., col2=...) -> None:
        ...
    
    def elementary_row_op(self, op=..., row=..., k=..., row1=..., row2=...) -> None:
        ...
    
    def columnspace(self, simplify=...) -> list[Any]:
        ...
    
    def nullspace(self, simplify=..., iszerofunc=...) -> list[Any]:
        ...
    
    def rowspace(self, simplify=...) -> list[Any]:
        ...
    
    def orthogonalize(cls, *vecs, **kwargs) -> list[Any]:
        ...
    
    orthogonalize = ...
    def eigenvals(self, error_when_incomplete=..., **flags) -> list[Any] | dict[Any, Any] | dict[Any, int] | Any:
        ...
    
    def eigenvects(self, error_when_incomplete=..., iszerofunc=..., **flags) -> list[Any] | list[tuple[Any, Any, list[Any]]]:
        ...
    
    def is_diagonalizable(self, reals_only=..., **kwargs) -> bool:
        ...
    
    def diagonalize(self, reals_only=..., sort=..., normalize=...) -> tuple[Any, Any]:
        ...
    
    def bidiagonalize(self, upper=...):
        ...
    
    def bidiagonal_decomposition(self, upper=...) -> tuple[Any, Any, Any]:
        ...
    
    @property
    def is_positive_definite(self) -> bool:
        ...
    
    @property
    def is_positive_semidefinite(self) -> bool | None:
        ...
    
    @property
    def is_negative_definite(self) -> bool:
        ...
    
    @property
    def is_negative_semidefinite(self) -> bool | None:
        ...
    
    @property
    def is_indefinite(self) -> bool | None:
        ...
    
    def jordan_form(self, calc_transform=..., **kwargs) -> list[Any] | tuple[Any, ...]:
        ...
    
    def left_eigenvects(self, **flags) -> list[tuple[Any, Any, list[Any]]]:
        ...
    
    def singular_values(self) -> Any | list[Any]:
        ...
    
    def diff(self, *args, evaluate=..., **kwargs) -> ArrayDerivative:
        ...
    
    def integrate(self, *args, **kwargs):
        ...
    
    def jacobian(self, X):
        ...
    
    def limit(self, *args):
        ...
    
    def berkowitz_charpoly(self, x=..., simplify=...) -> Any:
        ...
    
    def berkowitz_det(self) -> tuple[Any | Basic, bool] | Any | Basic | Order:
        ...
    
    def berkowitz_eigenvals(self, **flags) -> list[Any] | dict[Any, Any] | dict[Any, int] | Any:
        ...
    
    def berkowitz_minors(self) -> tuple[Any, ...]:
        ...
    
    def berkowitz(self) -> tuple[tuple[Literal[1]]] | tuple[tuple[Literal[1]], *tuple[tuple[Any, ...], ...]]:
        ...
    
    def cofactorMatrix(self, method=...):
        ...
    
    def det_bareis(self):
        ...
    
    def det_LU_decomposition(self) -> tuple[Any | Basic, bool] | Any | Basic | Order:
        ...
    
    def jordan_cell(self, eigenval, n):
        ...
    
    def jordan_cells(self, calc_transformation=...) -> tuple[Any, Any]:
        ...
    
    def minorEntry(self, i, j, method=...):
        ...
    
    def minorMatrix(self, i, j):
        ...
    
    def permuteBkwd(self, perm) -> None:
        ...
    
    def permuteFwd(self, perm) -> None:
        ...
    
    @property
    def kind(self) -> MatrixKind:
        ...
    
    def flat(self) -> list[Any]:
        ...
    
    def __array__(self, dtype=...) -> NDArray[Any, Any]:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __str__(self) -> str:
        ...
    
    @classmethod
    def irregular(cls, ntop, *matrices, **kwargs):
        ...
    
    def add(self, b):
        ...
    
    def condition_number(self):
        ...
    
    def copy(self):
        ...
    
    def cross(self, b):
        ...
    
    def hat(self):
        ...
    
    def vee(self):
        ...
    
    @property
    def D(self):
        ...
    
    def dot(self, b, hermitian=..., conjugate_convention=...) -> Any:
        ...
    
    def dual(self):
        ...
    
    def analytic_func(self, f, x):
        ...
    
    def exp(self) -> Self:
        ...
    
    def log(self, simplify=...) -> Self:
        ...
    
    def is_nilpotent(self) -> bool:
        ...
    
    def key2bounds(self, keys) -> tuple[Any | int, Any | int, Any | int, Any | int]:
        ...
    
    def key2ij(self, key) -> list[int | slice] | tuple[int, int]:
        ...
    
    def normalized(self, iszerofunc=...):
        ...
    
    def norm(self, ord=...) -> Pow | Order | Max | Min:
        ...
    
    def print_nonzero(self, symb=...) -> None:
        ...
    
    def project(self, v):
        ...
    
    def table(self, printer, rowstart=..., rowend=..., rowsep=..., colsep=..., align=...) -> str:
        ...
    
    def rank_decomposition(self, iszerofunc=..., simplify=...) -> tuple[Any, Any]:
        ...
    
    def cholesky(self, hermitian=...):
        ...
    
    def LDLdecomposition(self, hermitian=...):
        ...
    
    def LUdecomposition(self, iszerofunc=..., simpfunc=..., rankcheck=...) -> tuple[Any, Any, list[Any]]:
        ...
    
    def LUdecomposition_Simple(self, iszerofunc=..., simpfunc=..., rankcheck=...) -> tuple[Any, list[Any]]:
        ...
    
    def LUdecompositionFF(self) -> tuple[Any, Any, Any, Any]:
        ...
    
    def singular_value_decomposition(self) -> tuple[Any, Any, Any]:
        ...
    
    def QRdecomposition(self) -> tuple[Any, Any]:
        ...
    
    def upper_hessenberg_decomposition(self) -> tuple[Any, Any]:
        ...
    
    def diagonal_solve(self, rhs):
        ...
    
    def lower_triangular_solve(self, rhs):
        ...
    
    def upper_triangular_solve(self, rhs):
        ...
    
    def cholesky_solve(self, rhs):
        ...
    
    def LDLsolve(self, rhs):
        ...
    
    def LUsolve(self, rhs, iszerofunc=...):
        ...
    
    def QRsolve(self, b) -> Any:
        ...
    
    def gauss_jordan_solve(self, B, freevar=...) -> tuple[Self, Self, list[int]] | tuple[Self, Self]:
        ...
    
    def pinv_solve(self, B, arbitrary_matrix=...):
        ...
    
    def cramer_solve(self, rhs, det_method=...) -> Self:
        ...
    
    def solve(self, rhs, method=...):
        ...
    
    def solve_least_squares(self, rhs, method=...) -> Any:
        ...
    
    def pinv(self, method=...):
        ...
    
    def inverse_ADJ(self, iszerofunc=...):
        ...
    
    def inverse_BLOCK(self, iszerofunc=...) -> SparseMatrix | ImmutableDenseMatrix:
        ...
    
    def inverse_GE(self, iszerofunc=...):
        ...
    
    def inverse_LU(self, iszerofunc=...):
        ...
    
    def inverse_CH(self, iszerofunc=...):
        ...
    
    def inverse_LDL(self, iszerofunc=...):
        ...
    
    def inverse_QR(self, iszerofunc=...) -> Any:
        ...
    
    def inv(self, method=..., iszerofunc=..., try_block_diag=...) -> SparseMatrix:
        ...
    
    def connected_components(self) -> list[Any]:
        ...
    
    def connected_components_decomposition(self) -> tuple[PermutationMatrix, BlockDiagMatrix]:
        ...
    
    def strongly_connected_components(self) -> Any | list[Any]:
        ...
    
    def strongly_connected_components_decomposition(self, lower=...) -> tuple[PermutationMatrix, BlockMatrix]:
        ...
    
    _sage_ = ...


def classof(A, B):
    ...

def a2idx(j, n=...) -> int:
    ...

class DeferredVector(Symbol, NotIterable):
    def __getitem__(self, i) -> Symbol:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    


